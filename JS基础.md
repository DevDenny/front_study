# 函数
## 函数语法

重复代码：让程序难以维护

函数主要用于减少重复代码

### 创建（定义、声明）函数

```js
function 函数名(){
    // 函数体
}
```

函数体的代码不会直接运行，必须要手动调用函数，才能运行其中的代码。

### 调用函数

运行函数体

```js
函数名();
```

### 函数提升

通过字面量声明的函数，会提升到脚本块（<script></script>）的顶部。

通过字面量声明的函数，会成为全局对象(window.xxx)的属性。

### 其他特点

通过typeof 函数名，得到的结果是"function"

函数内部声明的变量：

1. 如果不使用var声明，和全局变量一致，表示给全局对象(window)添加属性
2. 如果使用var声明，变量提升到所在函数的顶部，函数外部不可以使用该变量

**函数中声明的变量，仅能在函数中使用，在外部无效**

### 参数

参数表示函数运行的未知条件，需要调用者告知的数据

```js
// 参数的有效范围在函数体中
function 函数名(形参1, 形参2, ...){
    
}

函数名(实参)

```

如果实参没有传递，则对应的形参为undefined





### 返回值

函数运行后，得到的结果，调用函数时，调用表达式的值就是函数的返回值

return 会直接结束整个函数的运行

return 后面如果不跟任何数据，返回undefined

如果函数中没有书写return，则该函数会在末尾自动return undefined。

### 文档注释

```js
/**
 *
 *
*/
```

## 作用域和闭包

### 作用域

作用域表示一个代码区域，也表示一个运行环境

JS中，有两种作用域：

1. 全局作用域

直接在脚本中书写的代码

在全局作用域中声明的变量，会被提升到脚本块的顶部，并且会成为全局对象(window)的属性。

2. 函数作用域

函数中的代码

在函数作用域中声明的变量，会被提升到函数的顶部，并且不会成为全局对象(window)的属性.

**因此，函数中声明的变量不会导致全局对象的污染**

**尽量的把功能封装在函数中**

但是，当函数成为一个表达式时，它既不会提升，也不会污染全局对象。

将函数变为一个函数表达式的方式之一，将函数用小括号括起来。

然而，这样一来，函数无法通过名称调用。

如果书写一个函数表达式，然后将立即调用，该函数称之为立即执行函数 IIFE（Imdiately Invoked Function Expression）。
==此处明白了erp中，(function test(){})();执行方式==

由于大部分情况下，函数表达式的函数名没有实际意义，因此，可以省略函数名。

没有名字的函数，称之为匿名函数(function(){})();

### 作用域中可以使用的变量

全局作用域只能使用全局作用域中声明的变量（包括函数）

函数作用域不仅能使用自身作用域中声明的变量（包括函数），还能使用外部环境的变量（包括函数）

有的时候，某个函数比较复杂，在编写的过程，可能需要另外一些函数来辅助它完成一些功能，而这些函数仅仅会被该函数使用，不会在其他位置使用，则可以将这些函数声明到该函数的内部。

函数内部声明的变量和外部冲突时，使用内部的。

### 闭包

闭包（closure），是一种现象，内部函数，可以使用外部函数环境中的变量。


## 函数表达式和this

### 函数表达式

JS中，函数也是一个数据，语法上，函数可以用于任何需要数据的地方

JS中，函数是一等公民

函数是一个引用类型，将其赋值给某个变量时，变量中保存的是函数的地址

函数表达式与声明字面量函数区别：
1.后者会提升，前面可以调用；
2.后者会中入window对像中；
3.前者都不会。

### this关键字

> this无法赋值

1. 在全局作用域中，this关键字固定指向全局对象（window === this）。
2. 在函数作用域中，取决于函数是如何被调用的
   1. 函数直接调用，this指向全局对象(window)
   2. 通过一个对象的属性调用，格式为```对象.属性()```或```对象["属性"]()```，this指向对象


## 构造函数

> 对象中的属性，如果是一个函数，也称该属性为对象的方法

### 用于创建对象的函数

用函数创建对象，可以减少繁琐的对象创建流程

1. 函数返回一个对象
2. 构造函数：构造函数专门用于创建对象

```js
new 函数名(参数);
```

如果使用上面的格式创建对象，则该函数叫做构造函数。

1) 函数名使用大驼峰命名法
2) 构造函数内部，会自动创建一个新对象，this指向新创建的对象，并且自动返回新对象
3) 构造函数中如果出现返回值，如果返回的是原始类型，则直接忽略；如果返回的是引用类型，则使用返回的结果
4) 所有的对象，最终都是通过构造函数创建的


### new.target

该表达式在函数中使用，返回的是当前的构造函数，但是，如果该函数不是通过new调用的，则返回undefined

通常用于判断某个函数是否是通过new在调用。


## 函数的本质

函数的本质就是对象。

> 某些教程中，将构造函数称之为构造器
> 所有的对象都是通过关键字new出来的，```new 构造函数()```

所有的函数，都是通过```new Function```创建。

> Function

由于函数本身就是对象，因此函数中，可以拥有各种属性。

### 包装类

JS为了增强原始类型的功能，为boolean、string、number分别创建了一个构造函数：

1. Boolean
2. String
3. Number

如果语法上，将原始类型当作对象使用时（一般是在使用属性时），JS会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性。
var a = 3.1223333;
a.toFixed(2);//取小数点后两位

> 类：在JS中，可以认为，类就是构造函数

> 成员属性（方法）、实例属性（方法）：表示该属性是通过构造函数创建的对象调用的。
> 静态属性（方法）、类属性（方法）：表示该属性是通过构造函数本身调用的。（Number.isNaN）


## 递归 

函数直接或间接调用自身

避免无限递归，无限递归会导致执行栈溢出。

对比死循环

- 死循环不会报错，也不会导致栈溢出
- 无限递归会导致栈溢出

### 执行栈

任何代码的执行都必须有一个执行环境，执行环境为代码的执行提供支持

执行环境是放到执行栈中的。

每个函数的调用，都需要创建一个函数的执行环境，函数调用结束，执行环境销毁。

执行栈有相对固定的大小，如果执行环境太多，执行栈无法容纳，会报错

### 尾递归

如果一个函数最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该语句称为尾调用，如果尾调用是调用自身函数，则称为尾递归。

某些语言或执行环境会对尾调用进行优化，它们会理解销毁当前函数，避免执行栈空间被占用。

在浏览器执行环境中，尾调用没有优化。但在nodejs环境中有优化。


# 标准库（标准API）

- 库：liberary
- API：应用程序编程接口，Application Programing Interface
- 标准：ECMAScript标准


## Object

### 静态成员

- keys(某个对象)，得到某个对象的所有属性名数组
- values(某个对象)，得到某个对象的所有属性值数组
- entries(某个对象)，得到某个对象的所有属性名和属性值的数组

### 实例成员

> 实例成员可以被重写

**所有对象，都拥有Object的所有实例成员**

- toString方法：得到某个对象的字符串格式

默认情况下，该方法返回"[object Object]";

- valueOf方法：得到某个对象的值

默认情况下，返回该对象本身

> 在JS中，当自动的进行类型转换时，如果要对一个对象进行转换，实际上是先调用对象的valueOf方法，然后调用返回结果的toString方法，将得到的结果进行进一步转换。

## Function

**所有函数都具有Function中的实例成员**

**语法：arguments：在函数中使用，获取该函数调用时，传递的所有参数**

**arguments是一个类数组（也称为伪数组：没有通过Array构造函数创建的类似于数组结构的对象），伪数组会缺少大量的数组实例方法**

**arguments数组中的值，会与对应的形参映射**

### 实例成员

- length属性，得到函数形参数量
- apply方法：调用函数，同时指定函数中的this指向，参数以数组传递
- call方法：调用函数，同时指定函数中的this指向，参数以列表传递
- bind方法：得到一个新函数，该函数中的this始终指向指定的值。
```js
        function sayHello(a, b) {
            console.log(this.name, this.age);
            console.log(a, b);
        }

        var user1 = {
            name: "asfd",
            age: 123
        };

        var user2 = {
            name: "546345",
            age: 11
        };
        var newFunc = sayHello.bind(user1, 1, 2);
        newFunc();
        newFunc();
        newFunc();

        sayHello.apply(user1, [1, 2]);
        sayHello.call(user2, 1, 2);
```
通常，可以利用apply、call方法，将某个伪数组转换伪真数组。
```js
function test() {
    console.log(arguments);
    //将arguments转换为真数组
    var newArr = [].slice.call(arguments)
    console.log(newArr);
}

test(23, 5, 6, 2, 233, 5, 6, 7);
```


## Array构造器

凡是通过Array构造函数创建的对象，都是数组

### 静态成员

- from方法：可以将一个伪数组转换为真数组
- isArray方法：判断一个给定的数据，是否为一个真数组
- of方法：类似于中括号创建数组，依次赋予数组每一项的值

### 实例成员

- fill方法：用某个数据填充数组
- pop方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。
- push方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。
- reverse：将当前数组颠倒顺序
- shift方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。
- sort：对数组进行排序
- splice方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。
- unshift方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。


纯函数、无副作用函数：不会导致当前对象发生改变

- concat方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。
- includes: 数组中是否包含满足条件的元素
- join方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串，用逗号或指定的分隔符字符串分隔。如果数组只有一个元素，那么将返回该元素而不使用分隔符。

- slice 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
- indexOf方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。
- lastIndexOf 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。
- forEach: 遍历数组
- every：是否所有元素都满足条件
- some：是否至少有一个元素满足条件
- filter：过滤，得到满足条件的元素组成的新数组
- find: 查找第一个满足条件的元素，返回元素本身，如果没有找到，返回undefined
- findIndex: 查找第一个满足条件的元素，返回元素的下标
- map：映射，将数组的每一项映射称为另外一项
- reduce：统计，累计;方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。


## 原始类型包装器

- new 包装器(值)：返回的是一个对象
- 包装器(值)：返回的是一个原始类型

### Number

#### 静态成员

- isNaN
- isFinite
- isInteger：判断一个数据是否是整数
- parseFloat: 将一个数据转换为小数
- parseInt：将以一个数据转换为整数，直接舍去小数部分

parseInt、parseFloat要求参数是一个字符串，如果不是字符串，则会先转换为字符串。
从字符串开始位置进行查找，找到第一个有效的数字进行转换，如果没有找到，则返回NaN，左右空白字符会忽略

parseInt，可以传入第二个参数，表示将给定的字符串，识别为多少进制。

#### 实例成员

- toFixed方法：会有四舍五入
- toPrecision：以指定的精度返回一个数字字符串

### Boolean

### String

#### 静态成员

- fromCharCode：通过unicode编码创建字符串

#### 实例成员

- length：字符串长度

字符串是一个伪数组

- charAt：得到指定位置的字符
- charCodeAt
- concat
- includes
- endsWith
- startsWith
- indexOf
- lastIndexOf
- padStart
- padEnd
- repeat
- slice：从某个位置取到某个位置；位置可以是负数；
- substr: 从某个位置开始取，取指定的长度；位置可以是负数；
- substring：从某个位置取到某个位置；不可以是负数；参数位置是可调换的。
- toLowerCase
- toUpperCase
- split：分割字符串


## Math对象

提供了一系列与数学相关的成员

> 常量：永远不会变化的数据。常量一般命名时所有字母大写，如果有多个单词，用下划线分割。

- random方法: 产生一个0~1之间的随机数
- PI属性：得到圆周率
- abs方法：求绝对值
- floor方法：对一个数向下取整
- ceil方法：对一个数向上取整
- max方法：得到一组数字的最大值；如果无参，得到-Infinity
- min方法：得到一组数字的最小值；如果无参，得到Infinity
- pow方法：求一个数字的幂次方
- round方法：得到一个四舍五入的整数

## Date构造函数

### 术语

1. 时间单位

年（year）
月（month）
日（date）
小时（hour）
分钟（minute）
秒（second）  =  1000ms
毫秒（millisecond，ms） = 1000 us
微秒（microsecond，us） = 1000 ns
纳秒（nanosecond，ns）

2. UTC和GMT

世界划分为24个时区，北京在东8区，格林威治在0时区。

GMT：Greenwish Mean Time 格林威治世界时。太阳时，精确到毫秒。
UTC：Universal Time Coodinated 世界协调时。以原子时间为计时标准，精确到纳秒。

UTC和GMT之间误差不超过0.9秒

GMT+0800  东8区

3. 时间戳

数字

1970-1-1 凌晨  到 某个时间  所经过的毫秒数

### 创建时间对象

- 直接调用函数（不适用new），忽略所有参数，直接返回当前时间的字符串。
- new Date(): 创建日期对象

1. 无参，当前时间
2. 1个参数，参数为数字，表示传入的是时间戳
3. 两个参数以上，分别表示：年、月、日、时、分、秒、毫秒

注意：月份的数字从0开始计算。

如果缺失参数，日期部分默认为1，时分秒毫秒默认为0。

月、日、时、分、秒、毫秒，均可以传递负数，如果传递负数，会根据指定日期进行计算。

### 实例成员

- getDate方法：得到日期部分
- getDay方法：得到星期几，0表示星期天
- getFullYear方法：得到年份
- getHours方法：得到小时部分
- getMinutes方法：得到分钟部分
- getSeconds方法：得到秒部分
- getMilliseconds方法：得到毫秒部分
- getTime方法：得到时间戳
- getMonth方法：得到月，从0开始计算

- setDate方法：设置日期
- setMonth方法：设置月份
- setFullYear方法：设置年
- setMinutes方法
- setSeconds方法
- setMilliseconds方法
- setTime方法：重新设置时间戳

- toDateString方法：将日期部分转换为可读的字符串。
- toISOString方法：将整个对象转换为ISO标准的字符串格式。
- toLocaleDateString方法：根据当前系统的地区设置，将日期部分转换为可读的字符串
- toLocaleString方法：根据当前系统的地区设置，将整个日期对象转换为可读的字符串
- toLocaleTimeString方法：根据当前系统的地区设置，将时间部分转换为可读的字符串


### 日期的运算

日期对象重写了Object中的valueOf方法，返回的是一个数字，表示时间戳

因此，日期对象可以进行数学运算


## 错误处理

JS中的错误分为：

1. 语法错误：会导致整个脚本块无法执行。
2. 运行错误
   1. 运行报错：会导致当前脚本块后续代码无法执行
   2. 运行结果不符合预期

### 调试错误

1. 控制台打印

2. 断点调试

### 抛出错误

错误在js中本质上是一个对象，抛出错误的语法为：

```js
throw 错误对象;
```

错误对象的构造函数为Error

### 捕获错误

```js
try{
    //代码块1
}
catch(错误对象){
    //代码块2
}
finally{
    //代码块3
}
```

当运行代码1的时候，如果发生错误，立即停止代码1的执行，转而执行代码2，错误对象为抛出的错误对象。无论代码1和代码2是否，最终都将执行代码3



# DOM核心

## web api概述

标准库：ECMAScript中的对象和函数

Web Api：浏览器宿主环境中的对象和函数

1. 知识繁杂
2. 成体系的知识
3. 程序思维：知识+程序思维 = 应用
4. 兼容性：了解，不记忆

Web Api：

- BOM：Browser Object Model，浏览器对象模型
- DOM：Document Object Model，文档对象模型

BOM：控制浏览器本身
DOM：控制HTML文档

ES 由 ECMAScript 规定的
WebApi 由 W3C（万维网联盟） 制定

### 关于DOM

- DOM 0
- DOM 1
- DOM 2
- DOM 3
- DOM 4  2015年


**DOM是什么**

DOM的核心理念，是将一个HTML或XML文档，用对象模型表示，每个对象称之为dom对象

dom对象又称之为节点Node

节点的类型：

- DocumentType，文档类型节点
- Document，文档节点，表示整个文档
- Comment，注释节点
- Element，元素节点
- Text，文本节点
- Attribute，属性节点
- DocumentFragment，文档片段节点

dom树：文档中不同的节点形成的树形结构。

## 获取dom节点

获取dom对象

> 全局对象 window 中有属性document，代表的是整个文档节点

### 旧的获取元素节点的方式

dom 0

- document.body：获取body元素节点
- document.head：获取head元素节点
- document.links：获取页面上所有的超链接元素节点，类数组
- document.anchors：获取页面上所有的锚链接(具有name属性)元素节点
- document.forms：获取页面中所有的form元素节点

### 新的获取元素节点的方式

#### 通过方法获取

- document.getElementById：通过id获取对应id的元素
- document.getElementsByTagName: 通过元素名称获取元素
- document.getElementsByClassName：通过元素的类样式获取元素，IE9以下无效
- document.getElementsByName：通过元素的name属性值获取元素
- document.querySelector：通过CSS选择器获取元素，得到匹配的第一个，IE8以下无效
- document.querySelectorAll：通过CSS选择器获取元素，得到所有匹配的结果，IE8以下无效
- document.documentElement: 获取根元素

细节：

1. 在所有的得到类数组的方法中，除了querySelectorAll，其他的方法都是实时更新的。
2. getElementById 得到元素执行效率最高。
3. 书写了id的元素，会自动成为window对象的属性。它是一个实时的单对象。事实上的标准。不推荐使用。
4. getElementsByTagName、getElementsByClassName、querySelector、querySelectorAll，可以作为其他元素节点对象的方法使用

#### 根据节点关系获取节点

- **parentNode**：获取父节点（元素、文档）
- previousSibling：获取上一个兄弟节点
- nextSibling：获取下一个兄弟节点
- childNodes：获取所有的子节点
- firstChild：获取第一个子节点
- lastChild：获取最后一个子节点
- attributes: 获取某个元素的属性节点


获取元素节点

- parentElement：获取父元素
- previousElementSibling：获取上一个兄弟元素
- nextElementSibling：获取下一个兄弟元素
- children：获取子元素
- firstElementChild：获取第一个子元素
- lastElementChild：获取最后一个子元素

### 获取节点信息

- nodeName：获取节点名称
- nodeValue：获取节点的值
- nodeType：节点类型，是一个数字



## dom元素操作

### 初识元素事件

元素事件：某个元素发生一件事（被点击 click）

事件处理程序：是一个函数，发生了一件事，应该做什么事情

注册事件：将事件处理程序与某个事件关联

**this关键字在事件处理程序中指代当前发生的事件元素**

### 获取和设置元素属性

- 通用方式：getAttribute、setAttribute

#### 可识别属性

正常的HTML属性

- dom对象.属性名：推荐

细节：

1. 正常的属性即使没有复制，也有默认值
2. 布尔属性在dom对象中，得到的是boolean
3. 某些表单元素可以获取到某些不存在的属性
4. 某些属性与标识符冲突，此时，需要更换属性名

#### 自定义属性

HTML5 建议自定义属性使用```data-```作为前缀

如果遵从HTML5 自定义属性规范，可以使用```dom对象.dataset.属性名```控制属性

删除自定义属性

- removeAttribute("属性名");
- delete dom.dataset.属性名

### 获取和设置元素内容

- innerHTML：获取和设置元素的内部HTML文本
- innerText：获取和设置元素内部的纯文本，仅得到元素内部显示出来的文本
- textContent：获取和设置元素内部的纯文本，textContent得到的是内部源代码中的文本

### 元素结构重构

- 父元素.appendChild(元素)：在某个元素末尾加入一个子元素
- 父元素.insertBefore(待插入的元素, 哪个元素之前)
- 父元素.replaceChild(替换的元素, 被替换的元素)

细节：

更改元素结构效率较低，尽量少用。

### 创建和删除元素

#### 创建元素

- document.createElement("元素名")：创建一个元素对象
  - document.createTextNode("文本")
  - document.createDocumentFragment(): 创建文档片段

- dom对象.cloneNode(是否深度克隆)：复制一个新的dom对象并返回

> childNodes也是实时集合

#### 删除元素

- removeChild：父元素调用，传入子元素
- remove：把自己删除

## dom元素样式

### 控制dom元素的类样式

- className： 获取或设置元素的类名
- classList： dom4的新属性，是一个用于控制元素类名的对象
  - add：用于添加一个类名
  - remove：用于移除一个类名
  - contains：用于判断一个类名是否存在
  - toggle：用于添加/移除一个类名


### 获取样式

**CSS的短横线命名，需要转换为小驼峰命名**

- dom.style：得到**行内样式**对象
- window.getComputedStyle(dom元素)：得到某个元素最终计算的样式
  - 可以有第二个参数，用于得到某个元素的某个伪元素样式

### 设置样式

dom.style.样式名 = 值

设置的是行内样式。


